# 导入
将你的所有代码放在一个文件中很快就会变得不可管理。`import`语句允许你从另一个文件中导入函数和全局变量。

`import filename`

这是最简单的导入语句形式。它将使你可以访问名为`filename`的文件中定义的所有内容。游戏中的每个窗口都是一个文件，文件名就是窗口顶部显示的名称。

这里有一个包含两个文件的示例：
文件名为helper：
```
x = 0

def say_hello():
    print("hello from helper")
```

其他文件：
```
import helper
helper.say_hello()
helper.x += 1
```

这里`import helper`运行文件名为`helper`的文件，并使你可以访问其所有的全局变量。然后，你可以使用`.`运算符访问导入模块中的变量和函数。所以在这个例子中，`helper.say_hello()`调用了helper中的`say_hello()`，而最后一行则增加了全局变量x。

你还可以使用`from`语法把导入模块的全局变量移动到当前的作用域中，执行导入语句的位置。

`from helper import *`
导入helper中的所有全局变量。

或者

`from helper import say_hello`
仅从helper中导入指定的全局变量。

这也导入了helper文件，但不是通过一个名为`helper`的变量访问它，而是从`helper`中解包全局变量并直接在本地作用域中赋值。

```
from helper import say_hello
say_hello()
```

这种形式的导入通常不推荐，因为当两个文件相互导入时不太好用，而且你可能会因为名称冲突而意外覆盖导入文件中的变量。

# 它的实际工作原理

## TLDR
导入可能非常不直观，但大多数问题可以通过坚持使用`import file`语法而不是`from file import`来避免，并将所有非全局定义的内容包装在`if __name__ == "__main__":`中。

## 导入副作用
第一次导入文件时，它将执行整个文件，然后让你访问在执行期间定义的所有变量。如果再次导入相同的文件，它只会返回第一次导入的缓存模块。

这意味着导入语句可以有副作用。例如，如果你导入一个调用`harvest()`的文件，它将在导入时实际执行收获。但再次导入时，它不会再次收获，因为文件只运行一次。

有一种方法可以使用`__name__`变量来避免此类副作用。当直接运行文件时，这个变量自动设置为`"__main__"`，而当通过`import`运行文件时，则设置为文件名。良好的习惯是将任何不希望在文件导入时运行的代码放在`if __name__ == "__main__":`块中。

Python中的常见文件结构是将文件运行时应执行的代码放入`main()`函数中。这样你就可以明显区分局部变量（在`main()`中定义）和可导入的全局变量（在`main()`外定义）。

```
a_global_variable = "global"

def main():
    a_local_variable = "local"
    # 执行任务

if __name__ == "__main__":
    main()
```

## 导入循环
如果文件`a`导入文件`b`，而文件`b`又导入文件`a`，会发生什么？

文件`a`：
```
import b
x = 0
```

文件`b`：
```
import a
def f():
    print(a.x)
```

这将正常工作。假设两个文件都尚未加载，然后有人执行`import a`。

-`a`运行直到`import b`行。
-`b`运行直到`import a`行。
-模块`a`已经存在，但不包含`x`，因为它只执行到`import b`行。
-`b`在一个名为`a`的变量中存储对半加载模块`a`的引用。
-`b`运行`def`语句并存储函数`f()`。
-`a`继续运行并初始化`x`。

当有人调用`b.f()`时，它将正确打印`0`，因为模块`b`引用的`a`现已完全加载。

现在，考虑使用`from`语法的相同代码。

文件`a`：
```
from b import *
x = 0
```

文件`b`：
```
from a import *
def f():
    print(x)
```

-`a`运行直到`from b import *`行。
-`b`运行直到`from a import *`行。
-模块`a`已经存在，但尚未完全执行。
-`b`将当前在`a`中的所有内容解包到自己的全局作用域中。此时，`a`不包含任何内容，因为它还没有到达`x = 0`行，所以没有导入任何内容。
-`b`运行`def`语句并存储函数`f()`。
-`a`继续运行并初始化`x`。

如果现在有人调用`b.f()`，他们将收到`x`不存在于当前作用域中的错误。这是因为这一次`b`没有引用仍在加载的`a`，并且看不到导入后添加的定义。