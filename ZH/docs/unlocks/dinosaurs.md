# 恐龙
恐龙是古老而宏伟的生物，可以用来获取远古骨头。

不幸的是，恐龙早已灭绝，所以我们现在最好的选择就是装扮成恐龙。
为此，你收到了新的恐龙帽子。

可以使用`change_hat(Hats.Dinosaur_Hat)`来装备这顶帽子。

遗憾的是，它看起来与广告有所不同……

如果你装备了恐龙帽子并且有足够的南瓜，一个[apple](objects/apple)将自动购买并被放置在无人机下。
当无人机移至一个苹果并再次移动时，它会吃掉苹果并使尾巴增长一个单位。
如果你能够承担费用，则会购买一个新的苹果并随机放置。
如果苹果想要生成的地方已经有种植物，那么苹果将无法生成。

恐龙的尾巴会被拖在无人机后面，填充无人机经过的前一个方格。
如果无人机试图移动到尾巴上，`move()`将失败并返回`False`。
尾巴的最后一节将在移动时避开，因此你可以移动到它上面。
然而，如果蛇占满了整个农田，你将无法再移动。所以你可以通过检查能否继续移动来判断蛇是否长满了。

使用`measure()`测量一个苹果时，将会返回下一个苹果的位置作为一个元组。

`next_x, next_y = measure()`

当你通过装备不同的帽子再取消装备恐龙帽子时，尾巴将被收割。
你将获得与尾巴长度平方相等的骨头。因此，对于长度为`n`的尾巴，你将获得`n**2`个`Items.Bone`。
例如：
长度 1 => 1 骨头
长度 2 => 4 骨头
长度 3 => 9 骨头
长度 4 => 16 骨头
长度 16 => 256 骨头
长度 100 => 10000 骨头

恐龙帽子非常重，所以如果你装备它，将使得`move()`耗时800 tick而不是200。
然而，每吃一个苹果，`move()`使用的tick数会减少3%（向下取整），因为更长的尾巴可以帮助你移动。

以下循环在任何数量的苹果后打印`move()`使用的tick数：

`ticks = 800
for i in range(100):
    print("ticks after ", i, " apples: ", ticks)
    ticks -= ticks * 0.03 // 1`

<spoiler=show hint 1>如果你沿着覆盖整个农田的同一条路径持续移动，你可以很容易每次都获得覆盖整个农田的蛇，因为你会在返回到尾巴所在位置之前覆盖所有空位。虽然不太高效，但可以。
大小不一的田地可能更难。如果你解锁了`Unlocks.Debug2`，你可以改变田地的大小以更方便的尺寸。</spoiler>