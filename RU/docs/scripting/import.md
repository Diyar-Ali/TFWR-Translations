# Импорт
Собрать весь код в одном файле может быстро стать неудобно. Операторы `import` позволяют импортировать функции и глобальные переменные из другого файла.

`import filename`

Это самая простая форма оператора импорта. Она даст вам доступ ко всему, что определено в файле с именем `filename`. Каждое окно в игре — это файл, а имя файла — это имя, показанное в верхней части окна.

Вот пример с двумя файлами:
Файл с именем helper:
`x = 0

def say_hello():
    print("hello from helper")`

Какой-то другой файл:
`import helper
helper.say_hello()
helper.x += 1`

Здесь `import helper` запускает файл с именем `helper` и дает доступ ко всем его глобальным переменным.
Вы можете получить доступ к переменным и функциям внутри импортированного модуля, используя оператор `.`.
Так, в этом примере `helper.say_hello()` вызывает `say_hello()` внутри helper, а последняя строка увеличивает глобальную переменную x.

Вы можете также переместить глобальные переменные из импортированного модуля в текущую область видимости, где выполняется оператор импорта, используя синтаксис `from`.

`from helper import *`
Импортирует все глобальные переменные из helper.

или

`from helper import say_hello`
Импортирует только указанные глобалы из helper.

Это также импортирует файл helper, но вместо доступа к нему через переменную с именем `helper`, он распаковывает глобалы из `helper` и присваивает их напрямую в локальной области видимости.

`from helper import say_hello
say_hello()`

Эта форма импорта обычно не рекомендуется, потому что она плохо работает, когда два файла импортируют друг друга, и вы можете случайно перезаписать переменные в импортирующем файле из-за совпадения имен.

# Как это действительно работает

## TLDR
Импорт может быть довольно неинтуитивным, но большинство проблем можно избежать, придерживаясь синтаксиса `import file` вместо `from file import` и оборачивая все, что не является глобальным определением, в `if __name__ == "__main__":`

## Побочные эффекты импорта
При первом импорте файла он выполнит весь файл, а затем предоставит вам доступ ко всем переменным, которые были определены во время выполнения. Если вы снова импортируете тот же файл, он просто вернет кешированный модуль с первого раза.

Это означает, что операторы импорта могут иметь побочные эффекты. Если вы импортируете файл, который вызывает `harvest()`, он действительно выполнит сбор во время импорта. Но когда вы импортируете его снова, он не выполнит сбор снова, потому что файл запускается только один раз.

Есть способ избежать таких побочных эффектов, используя переменную `__name__`. Это переменная, которая автоматически устанавливается в `"__main__"`, когда файл выполняется напрямую, и в имя файла, когда файл запускается через `import`.
Считается хорошей практикой помещать любой код, который вы не хотите запускать при импорте файла, внутрь блока `if __name__ == "__main__":`.

Обычная структура файла в Python — помещать код, который должен быть выполнен при запуске файла, в функцию `main()`. Таким образом, у вас есть четкое различие между локальными переменными (определенными внутри `main()`) и глобальными переменными, которые могут быть импортированы (определенные вне `main()`).

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # делаем что-то

if __name__ == "__main__":
    main()`

## Циклы импорта
Что произойдет, если файл `a` импортирует файл `b`, а файл `b` импортирует файл `a`?

файл `a`:
`import b
x = 0`

файл `b`:
`import a
def f():
    print(a.x)`

Это будет работать нормально. Допустим, ни один из двух файлов еще не загружен, и кто-то выполняет `import a`.

-`a` выполняется до строки `import b`.
-`b` выполняется до строки `import a`.
-Модуль `a` уже существует, но не содержит `x`, потому что достиг только строки `import b`.
-`b` сохраняет ссылку на полузагруженный модуль `a` в переменной под названием `a`.
-`b` выполняет оператор `def` и сохраняет функцию `f()`.
-`a` продолжает выполняться и инициализирует `x`.

Когда кто-то вызывает `b.f()`, это корректно выводит `0`, потому что модуль `a`, к которому у `b` есть ссылка, теперь полностью загружен.

Теперь рассмотрим тот же код, используя синтаксис `from`.

файл `a`:
`from b import *
x = 0`

файл `b`:
`from a import *
def f():
    print(x)`

-`a` выполняется до строки `from b import *`.
-`b` выполняется до строки `from a import *`.
-Модуль `a` уже существует, но еще не был полностью выполнен.
-`b` распаковывает все, что в данный момент находится в `a`, в свою собственную глобальную область. На этот момент `a` не содержит ничего, потому что он еще не достиг строки `x = 0`, поэтому ничего не импортируется.
-`b` выполняет оператор `def` и сохраняет функцию `f()`.
-`a` продолжает выполняться и инициализирует `x`.

Если кто-то теперь вызовет `b.f()`, они получат ошибку, что `x` не существует в текущей области. Это происходит потому, что на этот раз у `b` нет ссылки на все еще загружающийся `a` и он не видит определений, которые были добавлены после импорта.