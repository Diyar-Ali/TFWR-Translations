# Тайминг
Если ты действительно хочешь оптимизировать свои методы, тебе нужно понять, как измеряется время в этой игре. Этот раздел расскажет об этом.

## Новые функции
Есть две полезные функции для измерения времени выполнения:

`get_time()` возвращает время в секундах с начала игры.

`get_tick_count()` возвращает количество "тиков", выполненных с начала выполнения.

Эти две функции, а также `quick_print()`, полностью бесплатны. Даже вызов этих функций бесплатен.

## Детали выполнения

### Внимание
Такой подход к производительности не соответствует реальному миру. Это просто правила, придуманные для игры, чтобы создать понятную и последовательную модель тайминга.
Тебя это волновать вряд ли будет, только если ты хочешь супероптимизировать свой код.

Основная единица времени для выполнения кода называется "тик". Без улучшений скорости и мощности выполнение идет со скоростью `400` тиков в секунду.

В общем, операции, которые объединяют два значения, такие как `+, -, *, /, //, %, and, or, ...`, выполняются за один тик.
Операции с одним значением `-` и `not` бесплатны.
Ветвление `if` также занимает один тик (в дополнение к времени на проверку условия).
Вызовы функций и чтение/запись переменных бесплатны, но определения функций занимают 1 тик.
Операторы `import` бесплатны.
Доступ к импортированному модулю с помощью оператора `.` бесплатен.
Если функция или модуль были переданы через аргументы или присваивания, их использование будет стоить 1 тик вместо 0.
Циклы `for` и `while` занимают один тик на старт, но сами итерации бесплатны (не считая время на проверку условий/последовательности).
`return`, `break` и `continue` бесплатны.
`pass` занимает один тик, так что его можно использовать для создания точных задержек.
Индексирование в структуре данных занимает один тик для оператора индексации, а в случае с "dictionary" или "set" добавляет еще тики в зависимости от размера ключа.

Количество тиков, необходимых встроенным функциям для выполнения, задокументировано в документации каждой функции отдельно.