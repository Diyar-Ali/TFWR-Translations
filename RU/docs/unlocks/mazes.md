# Лабиринты
`Items.Weird_Substance`, полученное при [удобрении](docs/unlocks/fertilizer.md) растений, странным образом влияет на кусты. Если дрон находится над кустом и вы вызовете `use_item(Items.Weird_Substance, amount)`, куст превратится в лабиринт из живых изгородей.
Размер лабиринта зависит от количества используемого `Items.Weird_Substance` (это второй аргумент в вызове `use_item()`).
Без улучшений лабиринта, использование `n` `Items.Weird_Substance` создаёт лабиринт размером `n`x`n`. Для каждого уровня улучшений нужно использовать на `n` `Items.Weird_Substance` больше для достижения того же эффекта. 
Так что, чтобы сделать лабиринт на полном поле:

`plant(Entities.Bush)
n_substance = get_world_size() * num_unlocked(Unlocks.Mazes)
use_item(Items.Weird_Substance, n_substance)`

По какой-то причине дрон не может лететь над изгородью, хотя она и не выглядит слишком высокой.

В лабиринте спрятан клад. Используйте `harvest()` на кладе, чтобы получить золото, равное площади лабиринта. (Например, лабиринт 5x5 даст 25 золота.)

Если вы используете `harvest()` в любом другом месте, лабиринт просто исчезнет.

`get_entity_type()` равно `Entities.Treasure`, если дрон находится над кладом, и `Entities.Hedge` во всех остальных местах в лабиринте.

Лабиринты не содержат циклов, если только вы не переиспользуете лабиринт (смотрите ниже, как это сделать). Так что дрон не может оказаться в той же точке, не возвращаясь назад.

Вы можете проверить, есть ли стена, пытаясь пройти через неё. 
`move()` возвращает `True`, если удалось, и `False` в противном случае.

Если вы не знаете, как добраться до клада, посмотрите Подсказку 1. Она подскажет, как решать такую задачу.


Для дополнительного испытания вы можете снова использовать ту же самую `Items.Weird_Substance` на кладе.
Это увеличит количество золота в кладе на полный лабиринт и переместит клад в случайное место в лабиринте.

Используя `measure()` на кладе, вы получите позицию, куда он переместится, в виде кортежа.
`next_x, next_y = measure()`

Каждый раз, когда клад перемещается, одна случайная стена может быть удалена из лабиринта. Таким образом, переиспользованные лабиринты могут содержать циклы.

Обратите внимание, что циклы в лабиринте значительно усложняют задачу, ведь это значит, что можно попасть в одну и ту же точку опять, не двигаясь обратно.
Переиспользование лабиринта не даст вам больше золота, чем просто собирание урожая и создание нового лабиринта.
Это на 100% дополнительное испытание, которое вы можете просто пропустить.
Оно имеет смысл, только если дополнительная информация и короткие пути помогают вам быстрее решить лабиринт.

Один лабиринт можно решить не более 300 раз. Это соответствует 299 перемещениям. После этого использование странного вещества на кладе больше не увеличит его золото, и `measure()` вернёт `None`.

<spoiler=show hint 1>Вот общий подход к решению задачи:

Создайте лабиринт и представьте, что вы — дрон.

Подумайте, как бы вы попытались найти клад, если бы оказались в лабиринте.

Запишите вашу стратегию шаг за шагом, чтобы кто-то другой мог её выполнить, не задумываясь.

Теперь попытайтесь перевести свои шаги в код.
</spoiler>
<spoiler=show hint 2>Пока нет циклов: Все стены на самом деле представляют собой одну большую связанную стену. Если следовать вдоль стены, она проведёт вас через весь лабиринт.
Этот метод требует очень мало кода, и вы не нужно следить за тем, где вы уже были. Вам понадобится примерно 10 строк кода.</spoiler>
<spoiler=show hint 3>Вместо перемещения дрона в абсолютных направлениях, таких как восток или запад, может быть полезно перемещать дрон в относительных направлениях, таких как "повернуть направо" или "повернуть налево". Чтобы это сделать, вам нужно следить за тем, в каком направлении дрон движется в данный момент. Дрон на самом деле никогда не поворачивается, но вы можете всё равно держать "виртуальное" вращение в коде.
Следующий трик с индексами может быть полезен для этого:

`directions = [North, East, South, West]
index = 0`

Используйте `% 4`, чтобы вращать его "по кругу", так что после `West` он возвращается назад к `North`.
`# повернуть направо
index = (index + 1) % 4`

`# повернуть налево
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=show hint 4>Если вы не можете решить, всегда можно сделать свою жизнь легче и решить менее эффективно. 
Решение `1`x`1` лабиринта тривиально.</spoiler>