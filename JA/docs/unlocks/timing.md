# タイミング
メソッドを本当に最適化したいなら、このゲームで時間がどう測定されるかを理解する必要があります。このアンロックはそのためのものです。

## 新しい関数
物事にどれだけ時間がかかるかを測定するのに便利な関数が2つあります：

`get_time()` はゲーム開始からの秒数を返します。

`get_tick_count()` は実行開始から経過したティックの数を返します。

これら2つの関数と `quick_print()` はすべて完全に無料です。呼び出す操作も無料です。

## 実行時の詳細

### 知っておきたいこと
これは現実世界のパフォーマンスの仕組みではありません。これらは、このゲームのために一貫性のある理解しやすいタイミングモデルを作るためのルールです。
コードを超最適化したい場合にのみ気にすることになるでしょう。

コード実行の基本単位は「ティック」と呼ばれています。スピードアップグレードやパワーなしで、実行は1秒間に `400` ティックの速度で進みます。

一般に、`+, -, *, /, //, %, and, or, ...` のように2つの値を組み合わせる操作は実行に1ティックかかります。
単一の値に対する `-` と `not` は無料です。
`if` ブランチも実行に1ティックかかります（条件式の評価にかかる時間とは別に）。
関数の呼び出しや変数の読み取りと書き込みは無料ですが、関数の定義には1ティックかかります。
`import` 文は無料です。
`.` 演算子でインポートされたモジュールにアクセスするのも無料です。
関数やモジュールが引数や変数の代入で渡された場合、それを使うと0ティックではなく1ティックかかります。
`for` や `while` ループは開始に1ティックかかりますが、繰り返し自体は無料です（条件/シーケンス式の評価時間を除く）。
`return`、`break`、`continue` はすべて無料です。
`pass` は1ティックかかるので、正確な遅延を作るのに使えます。
データ構造へのインデックス操作には1ティックかかり、辞書やセットの場合、キーのサイズに応じて追加のティックが必要です。

組み込み関数が実行に必要なティック数は、それぞれの関数のドキュメントに個別に記載されています。