# 迷路
`Items.Weird_Substance`は、植物に[肥料を使うことで得られます](docs/unlocks/fertilizer.md)。このアイテムは茂みに奇妙な効果をもたらします。もしドローンが茂みの上にいて、`use_item(Items.Weird_Substance, amount)`を呼び出すと、茂みは生け垣の迷路に成長します。
迷路のサイズは、使用した`Items.Weird_Substance`の量（`use_item()`呼び出しの第二引数）によって決まります。
迷路のアップグレードがない場合、`n`個の`Items.Weird_Substance`を使うと`n`×`n`の迷路ができます。それぞれの迷路のアップグレードレベルにつき、同じ効果を得るためには追加で`n`個の`Items.Weird_Substance`が必要です。
フィールド全体の迷路を作るには：

`plant(Entities.Bush)
n_substance = get_world_size() * num_unlocked(Unlocks.Mazes)
use_item(Items.Weird_Substance, n_substance)`

なぜかドローンは生け垣を飛び越えられません。高く見えないのに不思議です。

生け垣のどこかに宝物が隠されています。`harvest()`をその宝物に使うと、迷路の面積に等しい量のゴールドを受け取れます。（例えば、5x5の迷路では25ゴールドを得ます。）

それ以外の場所で`harvest()`を使うと、迷路は単に消えてしまいます。

`get_entity_type()`は、ドローンが宝物の上にいると`Entities.Treasure`に、迷路の他の場所では`Entities.Hedge`になります。

迷路にはループは含まれません。再利用しない限り迷路を再利用する方法は以下を参照してください。したがって、ドローンが同じ場所に戻ってくることはありません。

壁があるかどうかは、動こうとしてみることで確認できます。
`move()`は成功すると`True`を返し、失敗すると`False`を返します。

どうやって宝物にたどり着くかわからないときは、ヒント1を見てみてください。このような問題に取り組む方法を教えてくれます。

チャレンジを追加したいときは、同じ量の`Items.Weird_Substance`を宝物に使い、迷路を再利用できます。
これにより、宝物の中のゴールドの量が1つの迷路分増え、宝物が迷路内のランダムな位置に移動します。

`measure()`を宝物に使うと、移動先の位置がタプルで返されます。
`next_x, next_y = measure()`

宝物が移動されるたびに、迷路の中からランダムで壁が取り除かれることがあります。再利用された迷路にはループが含まれることがあります。

ループがある迷路では、同じ場所に戻ることなく再訪できる可能性があるため、難易度が高くなります。
迷路を再利用しても、収穫して新しい迷路を生成するより多くのゴールドが得られるわけではありません。
これは100%追加のチャレンジで、飛ばしても構いません。
追加の情報や近道で速く解決できると思ったときだけ価値があります。

同じ迷路は最大300回まで解くことができます。これは299回の再配置に相当します。それ以上は、宝物に奇妙な物質を使ってもゴールドは増えず、`measure()`は`None`を返します。

<spoiler=show hint 1>問題を解決するための一般的なアプローチはこちら：

迷路を作り、自分がドローンになったと想像してください。

もしあなたが迷路の中にいたら、どうやって宝物を見つけようと考えるでしょうか。

誰でも考えずにそれに従えるように、一歩一歩書き留めてください。

そのステップをコードに翻訳してみましょう。
</spoiler>
<spoiler=show hint 2>ループがなければ、すべての壁は本当にただ1つの大きな連続した壁です。壁に沿って進むと、迷路全体を通り抜けることができます。
この方法は、コードが非常に少なくて済み、どこに既に行ったかを追跡する必要もありません。およそ10行のコードで充分です。</spoiler>
<spoiler=show hint 3>ドローンを絶対方向（東や西など）に動かす代わりに、相対方向（「右に回る」や「左に回る」など）に動かすと非常に便利です。そのためには、ドローンが現在どの方向に向かっているかを追跡する必要があります。ドローンは実際には回転しませんが、コードでは「仮想的」な回転を保持できます。
以下のインデックストリックが役立ちます:

`directions = [North, East, South, West]
index = 0`

`% 4`を使って、「円の周りを回転」させることができます。これにより`West`の後には再び`North`になります。
`# turn right
index = (index + 1) % 4`

`# turn left
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=show hint 4>解決できないなら、効率が悪くても簡単な方法で試してみることもできます。
`1`×`1`の迷路を解くのは簡単です。</spoiler>