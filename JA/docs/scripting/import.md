# インポート
すべてのコードを1つのファイルにまとめると、すぐに管理しきれなくなります。
`import`文は、他のファイルから関数やグローバル変数をインポートすることを可能にします。

`import filename`

これは最も簡単なインポート文の形式です。`filename`という名前のファイルに定義されているすべてにアクセスできるようになります。ゲーム内の各ウィンドウは1つのファイルであり、そのファイル名はウィンドウの上部に表示されます。

次に例を2つのファイルで示します：
helperという名前のファイル：
`x = 0

def say_hello():
    print("hello from helper")`

他のファイル：
`import helper
helper.say_hello()
helper.x += 1`

ここで`import helper`は`helper`という名前のファイルを実行し、そのグローバルにアクセスできるようにします。
その後、インポートされたモジュール内の変数や関数に`.`演算子を使ってアクセスできます。
この例では、`helper.say_hello()`がhelper内の`say_hello()`を呼び出し、最後の行でグローバル変数xが1増加します。

また、インポートステートメントが実行される現在のスコープに、インポートされたモジュールからグローバルを移動することができます。`from`構文を使って：

`from helper import *`
helperからすべてのグローバルをインポートします。

または

`from helper import say_hello`
helperから指定したグローバルのみをインポートします。

これもhelperファイルをインポートしますが、`helper`という名前の変数を通してアクセスする代わりに、`helper`からグローバルを展開し、直接ローカルスコープに割り当てます。

`from helper import say_hello
say_hello()`

この形式のインポートは通常お勧めしません。なぜなら、2つのファイルがお互いにインポートし合う際にうまく機能しないことが多く、名前の衝突でインポートしたファイル内の変数を誤って上書きしてしまうことがあるからです。

# 実際の動作

## TLDR
インポートは直感的ではない場合がありますが、ほとんどの問題は`import file`構文に従うことと、グローバル定義以外のすべてを
`if __name__ == "__main__":`でラップすることで回避できます。

## インポートの副作用
初めてファイルをインポートする際、そのファイル全体が実行され、その実行中に定義されたすべての変数にアクセスできるようになります。
同じファイルを再度インポートすると、1回目にキャッシュされたモジュールをそのまま返します。

これは、インポート文が副作用を持つことがあることを意味します。もし`harvest()`を呼び出すファイルをインポートすると、実際にインポート中に収穫を行います。しかし、再度インポートしても、そのファイルは一度しか実行されないので、もう一度収穫は行われません。

このような副作用を回避する方法の1つは、`__name__`という変数を使用することです。これは、ファイルが直接実行されるときには自動的に"__main__"に設定され、インポートを通して実行されるときにはファイル名に設定されます。ファイルがインポートされた際に実行したくないコードは`if __name__ == "__main__":`ブロックの中に入れるのが良い習慣とされています。

Pythonの一般的なファイル構成としては、ファイルが実行されるときに実行されるべきコードを`main()`関数に入れるというものがあります。これにより、ローカル変数（`main()`内で定義されたもの）とグローバル変数（`main()`の外で定義されたもの）を区別することができます。

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # 何かを実行する

if __name__ == "__main__":
    main()`

## インポートサイクル
ファイル`a`がファイル`b`をインポートし、さらにファイル`b`がファイル`a`をインポートするとどうなるでしょうか？

ファイル`a`：
`import b
x = 0`

ファイル`b`：
`import a
def f():
    print(a.x)`

これは問題なく動作します。たとえば、どちらのファイルもまだロードされておらず、誰かが`import a`を実行したとします。

-`a`は`import b`行まで実行されます。
-`b`は`import a`行まで実行されます。
-モジュール`a`はすでに存在しますが、`import b`行にしか到達していないため、`x`を含んでいません。
-`b`は半分ロードされたモジュール`a`への参照を変数`a`として保持します。
-`b`は`def`文を実行して関数`f()`を保存します。
-`a`はさらに実行されて`x`を初期化します。

誰かが`b.f()`を呼び出すと、モジュール`a`が正しくロードされているため、`0`が正しく印字されるでしょう。

次に、`from`構文を使用した同じコードを考えてみましょう。

ファイル`a`：
`from b import *
x = 0`

ファイル`b`：
`from a import *
def f():
    print(x)`

-`a`は`from b import *`行まで実行されます。
-`b`は`from a import *`行まで実行されます。
-モジュール`a`はすでに存在していますが、まだ完全には実行されていません。
-`b`は現在の`a`のすべてを自分のグローバルスコープに展開します。この時点で、`a`にはまだ何も含まれていません。なぜなら、`x = 0`行にまだ到達していないからです。そのため、何もインポートされません。
-`b`は`def`文を実行して関数`f()`を保存します。
-`a`はさらに実行されて`x`を初期化します。

もし誰かが`b.f()`を呼び出すと、現在のスコープに`x`が存在しないというエラーが発生します。これは今回、`b`がまだロード中の`a`への参照を持っておらず、インポート後に追加された定義を見ていないためです。