# 関数
新しい関数を定義するには、`def` キーワードを使います:
`def f(arg1, arg2 = False):
	# 関数コード`

関数を呼び出すには、呼び出し演算子 `()` を使います:
`f(42)`

関数内のローカル変数とグローバル変数について学ぶには [Scopes](docs/scripting/scopes.md) もご覧ください。

## 入門
すでに `harvest()` のような組み込み関数を見ています。
自分自身で関数を定義することもできるので、コードをモジュラーに構造化できます。これは、どこからでも呼び出せるように、コードブロックに名前を付けることを可能にすることです。

## 関数の定義
例えば、ドローンを複数回移動させる関数を定義することができます。

`def move_n_dir(n, dir):
	for i in range(n):
		move(dir)`

`def` キーワードは、これが関数定義であることを示しています。
`move_n_dir` は関数が結びつく名前です。これはどんな有効な変数名でもかまわず、関数を呼び出す際に使います。
`n` と `dir` はパラメータです。これらは関数に渡された値（引数とも呼ばれます）を保持する変数です。関数定義には、好きなだけ多くのパラメータを追加できます。
`:` の後に、関数が呼ばれたときに実行されるコードブロックが続きます。

上記の定義で、このコードはドローンを `10` マス `North` と `2` マス `West` に移動させます。

`move_n_dir(10, North)
move_n_dir(2, West)`

`def function():` を見るとき、それを次のような変数代入のように考えるべきです:
`function = create_new_function_object()`
すべての代入と同様、変数が代入される前に使うことはできません！
関数を呼び出す前に `def` 文が実行されなければなりません。
このコードはエラーを起こします:

`func()
def func():
	pass`

## 戻り値
関数が値を返すために `return` キーワードを使います。
例えば、次の関数は排他的論理和演算を定義しています。排他的論理和は、一方が `True` でもう片方が `False` の時に `True` を返します:

`def xor(a, b):
	return a != b

if xor(True, False):
	do_a_flip()`

[Tuples](docs/scripting/tuples.md) により、複数の値を返すことができます。

## デフォルト引数
引数が渡されなかったときに使用されるデフォルト値を設定することもできます。

`def f(a = False):
	if a:
		do_a_flip()

f()

f(True)`

デフォルト値を持つ引数の後には、デフォルト値を持たない引数を続けることはできません。

## 高度な関数の使い方
関数は他の値と同じように値であり、`def` 文は代入文のように、あなたが付けた名前に関数を割り当てます。
これにより、次のようなことが可能になります:

`def f():
	def d():
		do_a_flip()
	return d

f()()`

ここで `f()` は関数 `f` を呼び出し、新しい関数 `d` を定義して返します。2つ目の `()` は返された関数を実行し、フリップを行います。
（このようなことをすると何が起きているか理解しづらいので、通常はこういうことをするのは良くありません）

他の関数を引数として受け取る関数は、非常にクリエイティブになれるようになっています:

`def f(g, arg):
	for _ in range(10):
		g(arg)

f(move, North)
f(use_item, Items.Fertilizer)`

このコードはドローンを `North` に10回移動させ、その後肥料を10回使用します。