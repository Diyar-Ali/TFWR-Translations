# Name Scopes
스코프는 어떤 변수들이 어디서 접근될 수 있는지를 결정해요. 스코프는 기본적으로 이름에서 값으로의 매핑이에요.
Python에서와 거의 동일하게 작동합니다.

글로벌 스코프가 있고, 각 함수는 로컬 스코프를 가집니다.
변수를 정의하면, 현재 스코프에 추가됩니다.
함수 정의 외부에 있는 모든 것은 글로벌 스코프의 일부로 간주됩니다.

`x = 1`
`1`의 값을 글로벌 스코프에서 `x`라는 이름에 할당합니다.

이 `def` 문은 글로벌 스코프에서 `f`라는 이름에 함수를 할당합니다.
`def f():
    ` `f`의 로컬 스코프에서 `y`라는 이름에 `1`의 값을 할당합니다.`
    y = 1

    ` `f`의 로컬 스코프에서 `g`라는 이름에 함수를 할당합니다.`
    def g():
        pass`

`f()`
글로벌 스코프로부터 `f`에 저장된 함수를 호출합니다.

`print(y)`
글로벌 스코프에서 이 print 문은 에러를 발생시킵니다. 왜냐하면 `y`는 글로벌 스코프에서 선언된 적이 없어서 여기에선 읽을 수 없기 때문입니다.
그것은 오직 `f`의 로컬 스코프에만 존재했습니다.

## The global keyword
기본적으로 함수 내 모든 변수는 로컬 스코프에 바인딩되며, 같은 이름의 변수가 글로벌 스코프에 있어도 그렇습니다.

`x == 0

def f():
    x = 1
f()
print(x)`

이 코드는 `0`을 출력합니다.  왜냐하면 `f` 내부의 로컬 `x`는 글로벌 `x`와 같은 변수가 아니므로, 글로벌 `x`는 변경되지 않기 때문입니다. 이는 중요한데, 그렇지 않으면 함수 호출이 우연히 같은 이름의 글로벌 변수를 덮어쓸 수도 있습니다.

글로벌 변수를 작성하려면 `global` 키워드를 사용하여 명시적으로 해야 합니다.

`x == 0

def f():
    global x
    x = 1
f()
print(x)`

이 예제에서 `global x`는 `x`를 위에 정의된 글로벌 변수 `x`에 바인딩합니다. 이제 `1`를 출력합니다.
글로벌 변수를 변경하는 것은 보통 스파게티 코드로 가는 첫 걸음이니, 프로그램의 모든 부분이 다른 모든 부분에 영향을 미치게 되므로 너무 많이 사용하지 마세요.

## Loops and branches
루프와 분기는 자체 스코프를 만들지 않으므로, 그 안에서 선언된 것은 여전히 외부에서 사용할 수 있습니다.

`for i in range(3):
    pass
print(i)`

이는 `2`를 출력합니다. 왜냐하면 `for` 루프의 마지막 반복에서 `i`에 `2`를 할당했기 때문입니다.