# Import

모든 코드를 하나의 파일에 넣으면 금방 관리하기 어려워집니다. `import` 문을 사용하면 다른 파일에서 함수와 전역 변수를 가져올 수 있습니다.

`import filename`

이것은 가장 간단한 형식의 import 문입니다. `filename`이라는 이름의 파일에 정의된 모든 것에 접근할 수 있게 해줍니다. 게임의 각 창은 하나의 파일이며, 파일 이름은 창의 상단에 표시됩니다.

다음은 두 개의 파일을 사용하는 예제입니다:
helper라는 이름의 파일:
`x = 0

def say_hello():
    print("hello from helper")`

다른 파일:
`import helper
helper.say_hello()
helper.x += 1`

여기서 `import helper`는 `helper`라는 이름의 파일을 실행하고, 그 안의 모든 전역 변수에 접근할 수 있게 해줍니다. 이렇게 하면 `.` 연산자를 사용하여 가져온 모듈 내의 변수와 함수에 접근할 수 있습니다. 이 예제에서는 `helper.say_hello()`가 helper 내부의 `say_hello()`를 호출하고, 마지막 줄에서는 전역 변수 x를 증가시킵니다.

`from` 구문을 사용하여 가져온 모듈의 전역 변수를 현재 import 문이 실행되는 스코프로 이동할 수도 있습니다.

`from helper import *`
helper의 모든 전역 변수를 가져옵니다.

또는

`from helper import say_hello`
helper에서 지정한 전역 변수만 가져옵니다.

이것은 또한 helper 파일을 가져오지만, `helper`라는 변수로 접근하는 대신 `helper`에서 전역 변수를 풀어서 로컬 스코프에 직접 할당합니다.

`from helper import say_hello
say_hello()`

이 import 형식은 보통 추천되지 않는데, 두 파일이 서로를 가져올 때 잘 작동하지 않으며, 네임 충돌로 인해 가져오는 파일의 변수를 실수로 덮어쓸 수 있기 때문입니다.

# How it really works

## TLDR
Import는 꽤 직관적이지 않을 수 있지만, 대부분의 문제는 `import file` 구문에 충실하고,글로벌 정의가 아닌 모든 것을 `if __name__ == "__main__":` 안에 감싸서 피할 수 있습니다.

## Import Side Effects
파일을 처음 import할 때, 파일 전체가 실행되고 이후 실행 중에 정의된 모든 변수에 접근할 수 있게 됩니다. 같은 파일을 다시 import하면, 처음부터 다시 실행하지 않고 캐시된 모듈을 반환합니다.

이는 import 문이 부작용을 가질 수 있음을 의미합니다. `harvest()`를 호출하는 파일을 import하면, import 동안 실제로 수확이 이루어집니다. 하지만 다시 import하면 파일은 한 번만 실행되므로 다시 수확하지 않습니다.

부작용을 피할 방법은 `__name__` 변수를 사용하는 것입니다. 이 변수는 파일이 직접 실행될 때 자동으로 `"__main__"`으로 설정되고, `import`를 통해 실행될 때는 파일의 이름으로 설정됩니다. 파일이 import될 때 실행되지 않기를 원하는 코드는 `if __name__ == "__main__":` 블록 안에 넣는 것이 좋은 관행으로 여겨집니다.

Python에서 일반적인 파일 구조는 파일이 실행될 때 실행되어야 하는 코드를 `main()` 함수에 넣는 것입니다. 이렇게 하면 로컬 변수 (`main()` 안에 정의된)와 import 가능한 전역 변수 (`main()` 밖에 정의된) 간에 명확한 구분이 생깁니다.

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # do things

if __name__ == "__main__":
    main()`

## Import Cycles
파일 `a`가 파일 `b`를 import하고, 파일 `b`가 파일 `a`를 import하면 어떻게 될까요?

파일 `a`:
`import b
x = 0`

파일 `b`:
`import a
def f():
    print(a.x)`

이것은 잘 작동할 것입니다. 두 파일 중 어느 것도 아직 로드되지 않았다고 가정하고, 누군가가 `import a`를 실행합니다.

-`a`는 `import b` 줄까지 실행됩니다.
-`b`는 `import a` 줄까지 실행됩니다.
-모듈 `a`는 이미 존재하지만, 아직 `x`를 포함하지 않습니다. 이는 `import b` 줄까지만 도달했기 때문입니다.
-`b`는 아직 로드되지 않은 모듈 `a`에 대한 참조를 `a`라는 변수에 저장합니다.
-`b`는 `def` 문을 실행하고 함수 `f()`를 저장합니다.
-`a`는 계속 실행하여 `x`를 초기화합니다.

누군가 `b.f()`를 호출하면, 모듈 `a`가 이제 완전히 로드되었으므로 `0`을 정확하게 출력합니다.

동일한 코드를 `from` 구문을 사용하여 고려해 보겠습니다.

파일 `a`:
`from b import *
x = 0`

파일 `b`:
`from a import *
def f():
    print(x)`

-`a`는 `from b import *` 줄까지 실행됩니다.
-`b`는 `from a import *` 줄까지 실행됩니다.
-모듈 `a`는 이미 존재하지만, 아직 완전히 실행되지 않았습니다.
-`b`는 현재 `a`에 있는 모든 것을 자신의 전역 스코프로 풀어놓습니다. 이 시점에서 `a`에는 `x = 0` 줄에 도달하지 않았기 때문에 아무것도 없으므로, 아무것도 import되지 않습니다.
-`b`는 `def` 문을 실행하고 함수 `f()`를 저장합니다.
-`a`는 계속 실행하여 `x`를 초기화합니다.

이제 누군가 `b.f()`를 호출하면, 현재 범위에 `x`가 존재하지 않는다는 오류가 발생합니다. 이번에는 `b`가 아직 로드 중인 `a`에 대한 참조가 없고, import 후 추가된 정의를 보지 못하기 때문입니다.